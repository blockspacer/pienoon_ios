// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MOTIVE_MOTIVE_H_
#define FLATBUFFERS_GENERATED_MOTIVE_MOTIVE_H_

#include "flatbuffers/flatbuffers.h"


namespace motive {

struct Settled1fParameters;
struct ModularParameters;
struct OvershootParameters;
struct SmoothParameters;
struct TwitchParameters;

struct Settled1fParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float max_difference() const { return GetField<float>(4, 0); }
  float max_velocity() const { return GetField<float>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* max_difference */) &&
           VerifyField<float>(verifier, 6 /* max_velocity */) &&
           verifier.EndTable();
  }
};

struct Settled1fParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max_difference(float max_difference) { fbb_.AddElement<float>(4, max_difference, 0); }
  void add_max_velocity(float max_velocity) { fbb_.AddElement<float>(6, max_velocity, 0); }
  Settled1fParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Settled1fParametersBuilder &operator=(const Settled1fParametersBuilder &);
  flatbuffers::Offset<Settled1fParameters> Finish() {
    auto o = flatbuffers::Offset<Settled1fParameters>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Settled1fParameters> CreateSettled1fParameters(flatbuffers::FlatBufferBuilder &_fbb,
   float max_difference = 0,
   float max_velocity = 0) {
  Settled1fParametersBuilder builder_(_fbb);
  builder_.add_max_velocity(max_velocity);
  builder_.add_max_difference(max_difference);
  return builder_.Finish();
}

struct ModularParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint8_t modular() const { return GetField<uint8_t>(4, 0); }
  float min() const { return GetField<float>(6, 0); }
  float max() const { return GetField<float>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* modular */) &&
           VerifyField<float>(verifier, 6 /* min */) &&
           VerifyField<float>(verifier, 8 /* max */) &&
           verifier.EndTable();
  }
};

struct ModularParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modular(uint8_t modular) { fbb_.AddElement<uint8_t>(4, modular, 0); }
  void add_min(float min) { fbb_.AddElement<float>(6, min, 0); }
  void add_max(float max) { fbb_.AddElement<float>(8, max, 0); }
  ModularParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ModularParametersBuilder &operator=(const ModularParametersBuilder &);
  flatbuffers::Offset<ModularParameters> Finish() {
    auto o = flatbuffers::Offset<ModularParameters>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<ModularParameters> CreateModularParameters(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t modular = 0,
   float min = 0,
   float max = 0) {
  ModularParametersBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_modular(modular);
  return builder_.Finish();
}

struct OvershootParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const ModularParameters *base() const { return GetPointer<const ModularParameters *>(4); }
  float max_velocity() const { return GetField<float>(6, 0); }
  float max_delta() const { return GetField<float>(8, 0); }
  const Settled1fParameters *at_target() const { return GetPointer<const Settled1fParameters *>(10); }
  float acceleration_per_difference() const { return GetField<float>(12, 0); }
  float wrong_direction_acceleration_multiplier() const { return GetField<float>(14, 0); }
  int16_t max_delta_time() const { return GetField<int16_t>(16, 32767); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* base */) &&
           verifier.VerifyTable(base()) &&
           VerifyField<float>(verifier, 6 /* max_velocity */) &&
           VerifyField<float>(verifier, 8 /* max_delta */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* at_target */) &&
           verifier.VerifyTable(at_target()) &&
           VerifyField<float>(verifier, 12 /* acceleration_per_difference */) &&
           VerifyField<float>(verifier, 14 /* wrong_direction_acceleration_multiplier */) &&
           VerifyField<int16_t>(verifier, 16 /* max_delta_time */) &&
           verifier.EndTable();
  }
};

struct OvershootParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<ModularParameters> base) { fbb_.AddOffset(4, base); }
  void add_max_velocity(float max_velocity) { fbb_.AddElement<float>(6, max_velocity, 0); }
  void add_max_delta(float max_delta) { fbb_.AddElement<float>(8, max_delta, 0); }
  void add_at_target(flatbuffers::Offset<Settled1fParameters> at_target) { fbb_.AddOffset(10, at_target); }
  void add_acceleration_per_difference(float acceleration_per_difference) { fbb_.AddElement<float>(12, acceleration_per_difference, 0); }
  void add_wrong_direction_acceleration_multiplier(float wrong_direction_acceleration_multiplier) { fbb_.AddElement<float>(14, wrong_direction_acceleration_multiplier, 0); }
  void add_max_delta_time(int16_t max_delta_time) { fbb_.AddElement<int16_t>(16, max_delta_time, 32767); }
  OvershootParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  OvershootParametersBuilder &operator=(const OvershootParametersBuilder &);
  flatbuffers::Offset<OvershootParameters> Finish() {
    auto o = flatbuffers::Offset<OvershootParameters>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<OvershootParameters> CreateOvershootParameters(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<ModularParameters> base = 0,
   float max_velocity = 0,
   float max_delta = 0,
   flatbuffers::Offset<Settled1fParameters> at_target = 0,
   float acceleration_per_difference = 0,
   float wrong_direction_acceleration_multiplier = 0,
   int16_t max_delta_time = 32767) {
  OvershootParametersBuilder builder_(_fbb);
  builder_.add_wrong_direction_acceleration_multiplier(wrong_direction_acceleration_multiplier);
  builder_.add_acceleration_per_difference(acceleration_per_difference);
  builder_.add_at_target(at_target);
  builder_.add_max_delta(max_delta);
  builder_.add_max_velocity(max_velocity);
  builder_.add_base(base);
  builder_.add_max_delta_time(max_delta_time);
  return builder_.Finish();
}

struct SmoothParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const ModularParameters *base() const { return GetPointer<const ModularParameters *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* base */) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
};

struct SmoothParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<ModularParameters> base) { fbb_.AddOffset(4, base); }
  SmoothParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SmoothParametersBuilder &operator=(const SmoothParametersBuilder &);
  flatbuffers::Offset<SmoothParameters> Finish() {
    auto o = flatbuffers::Offset<SmoothParameters>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SmoothParameters> CreateSmoothParameters(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<ModularParameters> base = 0) {
  SmoothParametersBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

struct TwitchParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Settled1fParameters *settled() const { return GetPointer<const Settled1fParameters *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* settled */) &&
           verifier.VerifyTable(settled()) &&
           verifier.EndTable();
  }
};

struct TwitchParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_settled(flatbuffers::Offset<Settled1fParameters> settled) { fbb_.AddOffset(4, settled); }
  TwitchParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TwitchParametersBuilder &operator=(const TwitchParametersBuilder &);
  flatbuffers::Offset<TwitchParameters> Finish() {
    auto o = flatbuffers::Offset<TwitchParameters>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TwitchParameters> CreateTwitchParameters(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<Settled1fParameters> settled = 0) {
  TwitchParametersBuilder builder_(_fbb);
  builder_.add_settled(settled);
  return builder_.Finish();
}

}  // namespace motive

#endif  // FLATBUFFERS_GENERATED_MOTIVE_MOTIVE_H_
