// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COMPONENTS_FPL_PIE_NOON_H_
#define FLATBUFFERS_GENERATED_COMPONENTS_FPL_PIE_NOON_H_

#include "flatbuffers/flatbuffers.h"

#include "pie_noon_common_generated.h"
#include "motive_generated.h"

namespace fpl {
namespace pie_noon {
struct Vec2i;
struct Vec2;
struct Vec3;
struct Vec4;
struct Vec4ub;
}  // namespace pie_noon
}  // namespace fpl
namespace motive {
struct Settled1fParameters;
struct ModularParameters;
struct OvershootParameters;
struct SmoothParameters;
struct TwitchParameters;
}  // namespace motive

namespace fpl {
namespace pie_noon {

struct SceneObjectDef;
struct PlayerCharacterDef;
struct CardboardPlayerDef;
struct DripAndVanishDef;
struct MotivatorObjectDef;
struct ShakeablePropDef;
struct CardboardSceneryDef;
struct ComponentDefInstance;
struct EntityDefinition;

enum MotivatorDataUnion {
  MotivatorDataUnion_NONE = 0,
  MotivatorDataUnion_OvershootParameters = 1,
  MotivatorDataUnion_SmoothParameters = 2,
  MotivatorDataUnion_TwitchParameters = 3
};

inline const char **EnumNamesMotivatorDataUnion() {
  static const char *names[] = { "NONE", "OvershootParameters", "SmoothParameters", "TwitchParameters", nullptr };
  return names;
}

inline const char *EnumNameMotivatorDataUnion(MotivatorDataUnion e) { return EnumNamesMotivatorDataUnion()[e]; }

inline bool VerifyMotivatorDataUnion(flatbuffers::Verifier &verifier, const void *union_obj, MotivatorDataUnion type);

enum MotivatorSpecification {
  MotivatorSpecification_None = 0,
  MotivatorSpecification_Sway = 1,
  MotivatorSpecification_Pendulum = 2,
  MotivatorSpecification_Count = 3
};

inline const char **EnumNamesMotivatorSpecification() {
  static const char *names[] = { "None", "Sway", "Pendulum", "Count", nullptr };
  return names;
}

inline const char *EnumNameMotivatorSpecification(MotivatorSpecification e) { return EnumNamesMotivatorSpecification()[e]; }

enum ComponentDataUnion {
  ComponentDataUnion_NONE = 0,
  ComponentDataUnion_SceneObjectDef = 1,
  ComponentDataUnion_MotivatorObjectDef = 2,
  ComponentDataUnion_CardboardSceneryDef = 3,
  ComponentDataUnion_ShakeablePropDef = 4,
  ComponentDataUnion_DripAndVanishDef = 5,
  ComponentDataUnion_PlayerCharacterDef = 6,
  ComponentDataUnion_CardboardPlayerDef = 7
};

inline const char **EnumNamesComponentDataUnion() {
  static const char *names[] = { "NONE", "SceneObjectDef", "MotivatorObjectDef", "CardboardSceneryDef", "ShakeablePropDef", "DripAndVanishDef", "PlayerCharacterDef", "CardboardPlayerDef", nullptr };
  return names;
}

inline const char *EnumNameComponentDataUnion(ComponentDataUnion e) { return EnumNamesComponentDataUnion()[e]; }

inline bool VerifyComponentDataUnion(flatbuffers::Verifier &verifier, const void *union_obj, ComponentDataUnion type);

struct SceneObjectDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const fpl::pie_noon::Vec3 *position() const { return GetStruct<const fpl::pie_noon::Vec3 *>(4); }
  const fpl::pie_noon::Vec3 *scale() const { return GetStruct<const fpl::pie_noon::Vec3 *>(6); }
  const fpl::pie_noon::Vec3 *orientation() const { return GetStruct<const fpl::pie_noon::Vec3 *>(8); }
  const fpl::pie_noon::Vec3 *origin_point() const { return GetStruct<const fpl::pie_noon::Vec3 *>(10); }
  const fpl::pie_noon::Vec4 *tint() const { return GetStruct<const fpl::pie_noon::Vec4 *>(12); }
  fpl::pie_noon::RenderableId renderable_id() const { return static_cast<fpl::pie_noon::RenderableId>(GetField<uint16_t>(14, 0)); }
  uint8_t visible() const { return GetField<uint8_t>(16, 1); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fpl::pie_noon::Vec3>(verifier, 4 /* position */) &&
           VerifyField<fpl::pie_noon::Vec3>(verifier, 6 /* scale */) &&
           VerifyField<fpl::pie_noon::Vec3>(verifier, 8 /* orientation */) &&
           VerifyField<fpl::pie_noon::Vec3>(verifier, 10 /* origin_point */) &&
           VerifyField<fpl::pie_noon::Vec4>(verifier, 12 /* tint */) &&
           VerifyField<uint16_t>(verifier, 14 /* renderable_id */) &&
           VerifyField<uint8_t>(verifier, 16 /* visible */) &&
           verifier.EndTable();
  }
};

struct SceneObjectDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const fpl::pie_noon::Vec3 *position) { fbb_.AddStruct(4, position); }
  void add_scale(const fpl::pie_noon::Vec3 *scale) { fbb_.AddStruct(6, scale); }
  void add_orientation(const fpl::pie_noon::Vec3 *orientation) { fbb_.AddStruct(8, orientation); }
  void add_origin_point(const fpl::pie_noon::Vec3 *origin_point) { fbb_.AddStruct(10, origin_point); }
  void add_tint(const fpl::pie_noon::Vec4 *tint) { fbb_.AddStruct(12, tint); }
  void add_renderable_id(fpl::pie_noon::RenderableId renderable_id) { fbb_.AddElement<uint16_t>(14, static_cast<uint16_t>(renderable_id), 0); }
  void add_visible(uint8_t visible) { fbb_.AddElement<uint8_t>(16, visible, 1); }
  SceneObjectDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneObjectDefBuilder &operator=(const SceneObjectDefBuilder &);
  flatbuffers::Offset<SceneObjectDef> Finish() {
    auto o = flatbuffers::Offset<SceneObjectDef>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<SceneObjectDef> CreateSceneObjectDef(flatbuffers::FlatBufferBuilder &_fbb,
   const fpl::pie_noon::Vec3 *position = 0,
   const fpl::pie_noon::Vec3 *scale = 0,
   const fpl::pie_noon::Vec3 *orientation = 0,
   const fpl::pie_noon::Vec3 *origin_point = 0,
   const fpl::pie_noon::Vec4 *tint = 0,
   fpl::pie_noon::RenderableId renderable_id = fpl::pie_noon::RenderableId_Invalid,
   uint8_t visible = 1) {
  SceneObjectDefBuilder builder_(_fbb);
  builder_.add_tint(tint);
  builder_.add_origin_point(origin_point);
  builder_.add_orientation(orientation);
  builder_.add_scale(scale);
  builder_.add_position(position);
  builder_.add_renderable_id(renderable_id);
  builder_.add_visible(visible);
  return builder_.Finish();
}

struct PlayerCharacterDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerCharacterDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  PlayerCharacterDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PlayerCharacterDefBuilder &operator=(const PlayerCharacterDefBuilder &);
  flatbuffers::Offset<PlayerCharacterDef> Finish() {
    auto o = flatbuffers::Offset<PlayerCharacterDef>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<PlayerCharacterDef> CreatePlayerCharacterDef(flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerCharacterDefBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CardboardPlayerDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CardboardPlayerDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  CardboardPlayerDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CardboardPlayerDefBuilder &operator=(const CardboardPlayerDefBuilder &);
  flatbuffers::Offset<CardboardPlayerDef> Finish() {
    auto o = flatbuffers::Offset<CardboardPlayerDef>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<CardboardPlayerDef> CreateCardboardPlayerDef(flatbuffers::FlatBufferBuilder &_fbb) {
  CardboardPlayerDefBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DripAndVanishDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float total_lifetime() const { return GetField<float>(4, 0); }
  float time_spent_dripping() const { return GetField<float>(6, 0); }
  float distance_dripped() const { return GetField<float>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* total_lifetime */) &&
           VerifyField<float>(verifier, 6 /* time_spent_dripping */) &&
           VerifyField<float>(verifier, 8 /* distance_dripped */) &&
           verifier.EndTable();
  }
};

struct DripAndVanishDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_total_lifetime(float total_lifetime) { fbb_.AddElement<float>(4, total_lifetime, 0); }
  void add_time_spent_dripping(float time_spent_dripping) { fbb_.AddElement<float>(6, time_spent_dripping, 0); }
  void add_distance_dripped(float distance_dripped) { fbb_.AddElement<float>(8, distance_dripped, 0); }
  DripAndVanishDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DripAndVanishDefBuilder &operator=(const DripAndVanishDefBuilder &);
  flatbuffers::Offset<DripAndVanishDef> Finish() {
    auto o = flatbuffers::Offset<DripAndVanishDef>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<DripAndVanishDef> CreateDripAndVanishDef(flatbuffers::FlatBufferBuilder &_fbb,
   float total_lifetime = 0,
   float time_spent_dripping = 0,
   float distance_dripped = 0) {
  DripAndVanishDefBuilder builder_(_fbb);
  builder_.add_distance_dripped(distance_dripped);
  builder_.add_time_spent_dripping(time_spent_dripping);
  builder_.add_total_lifetime(total_lifetime);
  return builder_.Finish();
}

struct MotivatorObjectDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  MotivatorDataUnion data_type() const { return static_cast<MotivatorDataUnion>(GetField<uint8_t>(4, 0)); }
  const void *data() const { return GetPointer<const void *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* data_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* data */) &&
           VerifyMotivatorDataUnion(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct MotivatorObjectDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(MotivatorDataUnion data_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(6, data); }
  MotivatorObjectDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MotivatorObjectDefBuilder &operator=(const MotivatorObjectDefBuilder &);
  flatbuffers::Offset<MotivatorObjectDef> Finish() {
    auto o = flatbuffers::Offset<MotivatorObjectDef>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<MotivatorObjectDef> CreateMotivatorObjectDef(flatbuffers::FlatBufferBuilder &_fbb,
   MotivatorDataUnion data_type = MotivatorDataUnion_NONE,
   flatbuffers::Offset<void> data = 0) {
  MotivatorObjectDefBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct ShakeablePropDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  MotivatorSpecification shake_motivator() const { return static_cast<MotivatorSpecification>(GetField<uint16_t>(4, 0)); }
  float shake_scale() const { return GetField<float>(6, 0); }
  fpl::pie_noon::Axis shake_axis() const { return static_cast<fpl::pie_noon::Axis>(GetField<uint16_t>(8, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* shake_motivator */) &&
           VerifyField<float>(verifier, 6 /* shake_scale */) &&
           VerifyField<uint16_t>(verifier, 8 /* shake_axis */) &&
           verifier.EndTable();
  }
};

struct ShakeablePropDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shake_motivator(MotivatorSpecification shake_motivator) { fbb_.AddElement<uint16_t>(4, static_cast<uint16_t>(shake_motivator), 0); }
  void add_shake_scale(float shake_scale) { fbb_.AddElement<float>(6, shake_scale, 0); }
  void add_shake_axis(fpl::pie_noon::Axis shake_axis) { fbb_.AddElement<uint16_t>(8, static_cast<uint16_t>(shake_axis), 0); }
  ShakeablePropDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShakeablePropDefBuilder &operator=(const ShakeablePropDefBuilder &);
  flatbuffers::Offset<ShakeablePropDef> Finish() {
    auto o = flatbuffers::Offset<ShakeablePropDef>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<ShakeablePropDef> CreateShakeablePropDef(flatbuffers::FlatBufferBuilder &_fbb,
   MotivatorSpecification shake_motivator = MotivatorSpecification_None,
   float shake_scale = 0,
   fpl::pie_noon::Axis shake_axis = fpl::pie_noon::Axis_X) {
  ShakeablePropDefBuilder builder_(_fbb);
  builder_.add_shake_scale(shake_scale);
  builder_.add_shake_axis(shake_axis);
  builder_.add_shake_motivator(shake_motivator);
  return builder_.Finish();
}

struct CardboardSceneryDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CardboardSceneryDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  CardboardSceneryDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CardboardSceneryDefBuilder &operator=(const CardboardSceneryDefBuilder &);
  flatbuffers::Offset<CardboardSceneryDef> Finish() {
    auto o = flatbuffers::Offset<CardboardSceneryDef>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<CardboardSceneryDef> CreateCardboardSceneryDef(flatbuffers::FlatBufferBuilder &_fbb) {
  CardboardSceneryDefBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ComponentDefInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  ComponentDataUnion data_type() const { return static_cast<ComponentDataUnion>(GetField<uint8_t>(4, 0)); }
  const void *data() const { return GetPointer<const void *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* data_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* data */) &&
           VerifyComponentDataUnion(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct ComponentDefInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(ComponentDataUnion data_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(6, data); }
  ComponentDefInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ComponentDefInstanceBuilder &operator=(const ComponentDefInstanceBuilder &);
  flatbuffers::Offset<ComponentDefInstance> Finish() {
    auto o = flatbuffers::Offset<ComponentDefInstance>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ComponentDefInstance> CreateComponentDefInstance(flatbuffers::FlatBufferBuilder &_fbb,
   ComponentDataUnion data_type = ComponentDataUnion_NONE,
   flatbuffers::Offset<void> data = 0) {
  ComponentDefInstanceBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct EntityDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<ComponentDefInstance>> *component_list() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ComponentDefInstance>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* component_list */) &&
           verifier.Verify(component_list()) &&
           verifier.VerifyVectorOfTables(component_list()) &&
           verifier.EndTable();
  }
};

struct EntityDefinitionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_component_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ComponentDefInstance>>> component_list) { fbb_.AddOffset(4, component_list); }
  EntityDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EntityDefinitionBuilder &operator=(const EntityDefinitionBuilder &);
  flatbuffers::Offset<EntityDefinition> Finish() {
    auto o = flatbuffers::Offset<EntityDefinition>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<EntityDefinition> CreateEntityDefinition(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ComponentDefInstance>>> component_list = 0) {
  EntityDefinitionBuilder builder_(_fbb);
  builder_.add_component_list(component_list);
  return builder_.Finish();
}

inline bool VerifyMotivatorDataUnion(flatbuffers::Verifier &verifier, const void *union_obj, MotivatorDataUnion type) {
  switch (type) {
    case MotivatorDataUnion_NONE: return true;
    case MotivatorDataUnion_OvershootParameters: return verifier.VerifyTable(reinterpret_cast<const motive::OvershootParameters *>(union_obj));
    case MotivatorDataUnion_SmoothParameters: return verifier.VerifyTable(reinterpret_cast<const motive::SmoothParameters *>(union_obj));
    case MotivatorDataUnion_TwitchParameters: return verifier.VerifyTable(reinterpret_cast<const motive::TwitchParameters *>(union_obj));
    default: return false;
  }
}

inline bool VerifyComponentDataUnion(flatbuffers::Verifier &verifier, const void *union_obj, ComponentDataUnion type) {
  switch (type) {
    case ComponentDataUnion_NONE: return true;
    case ComponentDataUnion_SceneObjectDef: return verifier.VerifyTable(reinterpret_cast<const SceneObjectDef *>(union_obj));
    case ComponentDataUnion_MotivatorObjectDef: return verifier.VerifyTable(reinterpret_cast<const MotivatorObjectDef *>(union_obj));
    case ComponentDataUnion_CardboardSceneryDef: return verifier.VerifyTable(reinterpret_cast<const CardboardSceneryDef *>(union_obj));
    case ComponentDataUnion_ShakeablePropDef: return verifier.VerifyTable(reinterpret_cast<const ShakeablePropDef *>(union_obj));
    case ComponentDataUnion_DripAndVanishDef: return verifier.VerifyTable(reinterpret_cast<const DripAndVanishDef *>(union_obj));
    case ComponentDataUnion_PlayerCharacterDef: return verifier.VerifyTable(reinterpret_cast<const PlayerCharacterDef *>(union_obj));
    case ComponentDataUnion_CardboardPlayerDef: return verifier.VerifyTable(reinterpret_cast<const CardboardPlayerDef *>(union_obj));
    default: return false;
  }
}

}  // namespace pie_noon
}  // namespace fpl

#endif  // FLATBUFFERS_GENERATED_COMPONENTS_FPL_PIE_NOON_H_
