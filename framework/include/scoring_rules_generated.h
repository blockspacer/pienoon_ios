// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCORINGRULES_FPL_PIE_NOON_H_
#define FLATBUFFERS_GENERATED_SCORINGRULES_FPL_PIE_NOON_H_

#include "flatbuffers/flatbuffers.h"


namespace fpl {
namespace pie_noon {

struct Rule;
struct ScoringRules;

enum ScoreEvent {
  ScoreEvent_ThrewPie = 0,
  ScoreEvent_HitByPie = 1,
  ScoreEvent_DeflectedPie = 2,
  ScoreEvent_YourPieHitSomeone = 3,
  ScoreEvent_HitSomeoneWithPie = 4
};

inline const char **EnumNamesScoreEvent() {
  static const char *names[] = { "ThrewPie", "HitByPie", "DeflectedPie", "YourPieHitSomeone", "HitSomeoneWithPie", nullptr };
  return names;
}

inline const char *EnumNameScoreEvent(ScoreEvent e) { return EnumNamesScoreEvent()[e]; }

enum RewardType {
  RewardType_None = 0,
  RewardType_AddDamage = 1,
  RewardType_SubtractDamage = 2,
  RewardType_AddPointValue = 3
};

inline const char **EnumNamesRewardType() {
  static const char *names[] = { "None", "AddDamage", "SubtractDamage", "AddPointValue", nullptr };
  return names;
}

inline const char *EnumNameRewardType(RewardType e) { return EnumNamesRewardType()[e]; }

struct Rule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  ScoreEvent event() const { return static_cast<ScoreEvent>(GetField<uint16_t>(4, 0)); }
  RewardType reward_type() const { return static_cast<RewardType>(GetField<uint16_t>(6, 0)); }
  int32_t point_value() const { return GetField<int32_t>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* event */) &&
           VerifyField<uint16_t>(verifier, 6 /* reward_type */) &&
           VerifyField<int32_t>(verifier, 8 /* point_value */) &&
           verifier.EndTable();
  }
};

struct RuleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event(ScoreEvent event) { fbb_.AddElement<uint16_t>(4, static_cast<uint16_t>(event), 0); }
  void add_reward_type(RewardType reward_type) { fbb_.AddElement<uint16_t>(6, static_cast<uint16_t>(reward_type), 0); }
  void add_point_value(int32_t point_value) { fbb_.AddElement<int32_t>(8, point_value, 0); }
  RuleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RuleBuilder &operator=(const RuleBuilder &);
  flatbuffers::Offset<Rule> Finish() {
    auto o = flatbuffers::Offset<Rule>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Rule> CreateRule(flatbuffers::FlatBufferBuilder &_fbb,
   ScoreEvent event = ScoreEvent_ThrewPie,
   RewardType reward_type = RewardType_None,
   int32_t point_value = 0) {
  RuleBuilder builder_(_fbb);
  builder_.add_point_value(point_value);
  builder_.add_reward_type(reward_type);
  builder_.add_event(event);
  return builder_.Finish();
}

struct ScoringRules FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<Rule>> *rules() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Rule>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* rules */) &&
           verifier.Verify(rules()) &&
           verifier.VerifyVectorOfTables(rules()) &&
           verifier.EndTable();
  }
};

struct ScoringRulesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Rule>>> rules) { fbb_.AddOffset(4, rules); }
  ScoringRulesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ScoringRulesBuilder &operator=(const ScoringRulesBuilder &);
  flatbuffers::Offset<ScoringRules> Finish() {
    auto o = flatbuffers::Offset<ScoringRules>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ScoringRules> CreateScoringRules(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Rule>>> rules = 0) {
  ScoringRulesBuilder builder_(_fbb);
  builder_.add_rules(rules);
  return builder_.Finish();
}

}  // namespace pie_noon
}  // namespace fpl

#endif  // FLATBUFFERS_GENERATED_SCORINGRULES_FPL_PIE_NOON_H_
