// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MESH_MESHDEF_H_
#define FLATBUFFERS_GENERATED_MESH_MESHDEF_H_

#include "flatbuffers/flatbuffers.h"

#include "pie_noon_common_generated.h"

namespace fpl {
namespace pie_noon {
struct Vec2i;
struct Vec2;
struct Vec3;
struct Vec4;
struct Vec4ub;
}  // namespace pie_noon
}  // namespace fpl

namespace meshdef {

struct Surface;
struct Mesh;

struct Surface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<uint16_t> *indices() const { return GetPointer<const flatbuffers::Vector<uint16_t> *>(4); }
  const flatbuffers::String *material() const { return GetPointer<const flatbuffers::String *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 4 /* indices */) &&
           verifier.Verify(indices()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 6 /* material */) &&
           verifier.Verify(material()) &&
           verifier.EndTable();
  }
};

struct SurfaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> indices) { fbb_.AddOffset(4, indices); }
  void add_material(flatbuffers::Offset<flatbuffers::String> material) { fbb_.AddOffset(6, material); }
  SurfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SurfaceBuilder &operator=(const SurfaceBuilder &);
  flatbuffers::Offset<Surface> Finish() {
    auto o = flatbuffers::Offset<Surface>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, 4);  // indices
    fbb_.Required(o, 6);  // material
    return o;
  }
};

inline flatbuffers::Offset<Surface> CreateSurface(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<uint16_t>> indices = 0,
   flatbuffers::Offset<flatbuffers::String> material = 0) {
  SurfaceBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_indices(indices);
  return builder_.Finish();
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<Surface>> *surfaces() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Surface>> *>(4); }
  const flatbuffers::Vector<const fpl::pie_noon::Vec3 *> *positions() const { return GetPointer<const flatbuffers::Vector<const fpl::pie_noon::Vec3 *> *>(6); }
  const flatbuffers::Vector<const fpl::pie_noon::Vec3 *> *normals() const { return GetPointer<const flatbuffers::Vector<const fpl::pie_noon::Vec3 *> *>(8); }
  const flatbuffers::Vector<const fpl::pie_noon::Vec4 *> *tangents() const { return GetPointer<const flatbuffers::Vector<const fpl::pie_noon::Vec4 *> *>(10); }
  const flatbuffers::Vector<const fpl::pie_noon::Vec4ub *> *colors() const { return GetPointer<const flatbuffers::Vector<const fpl::pie_noon::Vec4ub *> *>(12); }
  const flatbuffers::Vector<const fpl::pie_noon::Vec2 *> *texcoords() const { return GetPointer<const flatbuffers::Vector<const fpl::pie_noon::Vec2 *> *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 4 /* surfaces */) &&
           verifier.Verify(surfaces()) &&
           verifier.VerifyVectorOfTables(surfaces()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 6 /* positions */) &&
           verifier.Verify(positions()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* normals */) &&
           verifier.Verify(normals()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* tangents */) &&
           verifier.Verify(tangents()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* colors */) &&
           verifier.Verify(colors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* texcoords */) &&
           verifier.Verify(texcoords()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_surfaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Surface>>> surfaces) { fbb_.AddOffset(4, surfaces); }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec3 *>> positions) { fbb_.AddOffset(6, positions); }
  void add_normals(flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec3 *>> normals) { fbb_.AddOffset(8, normals); }
  void add_tangents(flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec4 *>> tangents) { fbb_.AddOffset(10, tangents); }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec4ub *>> colors) { fbb_.AddOffset(12, colors); }
  void add_texcoords(flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec2 *>> texcoords) { fbb_.AddOffset(14, texcoords); }
  MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    auto o = flatbuffers::Offset<Mesh>(fbb_.EndTable(start_, 6));
    fbb_.Required(o, 4);  // surfaces
    fbb_.Required(o, 6);  // positions
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Surface>>> surfaces = 0,
   flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec3 *>> positions = 0,
   flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec3 *>> normals = 0,
   flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec4 *>> tangents = 0,
   flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec4ub *>> colors = 0,
   flatbuffers::Offset<flatbuffers::Vector<const fpl::pie_noon::Vec2 *>> texcoords = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_texcoords(texcoords);
  builder_.add_colors(colors);
  builder_.add_tangents(tangents);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  builder_.add_surfaces(surfaces);
  return builder_.Finish();
}

inline const meshdef::Mesh *GetMesh(const void *buf) { return flatbuffers::GetRoot<meshdef::Mesh>(buf); }

inline bool VerifyMeshBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<meshdef::Mesh>(); }

inline const char *MeshIdentifier() { return "FPLM"; }

inline bool MeshBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, MeshIdentifier()); }

inline const char *MeshExtension() { return "fplmesh"; }

inline void FinishMeshBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<meshdef::Mesh> root) { fbb.Finish(root, MeshIdentifier()); }

}  // namespace meshdef

#endif  // FLATBUFFERS_GENERATED_MESH_MESHDEF_H_
