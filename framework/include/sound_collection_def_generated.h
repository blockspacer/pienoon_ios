// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SOUNDCOLLECTIONDEF_PINDROP_H_
#define FLATBUFFERS_GENERATED_SOUNDCOLLECTIONDEF_PINDROP_H_

#include "flatbuffers/flatbuffers.h"


namespace pindrop {

struct AudioSample;
struct AudioSampleSetEntry;
struct SoundCollectionDef;

enum Mode {
  Mode_Nonpositional = 0,
  Mode_Positional = 1
};

inline const char **EnumNamesMode() {
  static const char *names[] = { "Nonpositional", "Positional", nullptr };
  return names;
}

inline const char *EnumNameMode(Mode e) { return EnumNamesMode()[e]; }

struct AudioSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float gain() const { return GetField<float>(4, 1.0); }
  const flatbuffers::String *filename() const { return GetPointer<const flatbuffers::String *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* gain */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* filename */) &&
           verifier.Verify(filename()) &&
           verifier.EndTable();
  }
};

struct AudioSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gain(float gain) { fbb_.AddElement<float>(4, gain, 1.0); }
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) { fbb_.AddOffset(6, filename); }
  AudioSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AudioSampleBuilder &operator=(const AudioSampleBuilder &);
  flatbuffers::Offset<AudioSample> Finish() {
    auto o = flatbuffers::Offset<AudioSample>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AudioSample> CreateAudioSample(flatbuffers::FlatBufferBuilder &_fbb,
   float gain = 1.0,
   flatbuffers::Offset<flatbuffers::String> filename = 0) {
  AudioSampleBuilder builder_(_fbb);
  builder_.add_filename(filename);
  builder_.add_gain(gain);
  return builder_.Finish();
}

struct AudioSampleSetEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float playback_probability() const { return GetField<float>(4, 1.0); }
  const AudioSample *audio_sample() const { return GetPointer<const AudioSample *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* playback_probability */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* audio_sample */) &&
           verifier.VerifyTable(audio_sample()) &&
           verifier.EndTable();
  }
};

struct AudioSampleSetEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playback_probability(float playback_probability) { fbb_.AddElement<float>(4, playback_probability, 1.0); }
  void add_audio_sample(flatbuffers::Offset<AudioSample> audio_sample) { fbb_.AddOffset(6, audio_sample); }
  AudioSampleSetEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AudioSampleSetEntryBuilder &operator=(const AudioSampleSetEntryBuilder &);
  flatbuffers::Offset<AudioSampleSetEntry> Finish() {
    auto o = flatbuffers::Offset<AudioSampleSetEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AudioSampleSetEntry> CreateAudioSampleSetEntry(flatbuffers::FlatBufferBuilder &_fbb,
   float playback_probability = 1.0,
   flatbuffers::Offset<AudioSample> audio_sample = 0) {
  AudioSampleSetEntryBuilder builder_(_fbb);
  builder_.add_audio_sample(audio_sample);
  builder_.add_playback_probability(playback_probability);
  return builder_.Finish();
}

struct SoundCollectionDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  float priority() const { return GetField<float>(6, 1.0); }
  float gain() const { return GetField<float>(8, 1.0); }
  const flatbuffers::String *bus() const { return GetPointer<const flatbuffers::String *>(10); }
  uint8_t loop() const { return GetField<uint8_t>(12, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<AudioSampleSetEntry>> *audio_sample_set() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AudioSampleSetEntry>> *>(14); }
  uint8_t stream() const { return GetField<uint8_t>(16, 0); }
  Mode mode() const { return static_cast<Mode>(GetField<int8_t>(18, 0)); }
  float min_audible_radius() const { return GetField<float>(20, 0.0); }
  float max_audible_radius() const { return GetField<float>(22, 0.0); }
  float roll_in_radius() const { return GetField<float>(24, 0.0); }
  float roll_out_radius() const { return GetField<float>(26, 0.0); }
  float roll_in_curve_factor() const { return GetField<float>(28, 2.0); }
  float roll_out_curve_factor() const { return GetField<float>(30, 0.5); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<float>(verifier, 6 /* priority */) &&
           VerifyField<float>(verifier, 8 /* gain */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* bus */) &&
           verifier.Verify(bus()) &&
           VerifyField<uint8_t>(verifier, 12 /* loop */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* audio_sample_set */) &&
           verifier.Verify(audio_sample_set()) &&
           verifier.VerifyVectorOfTables(audio_sample_set()) &&
           VerifyField<uint8_t>(verifier, 16 /* stream */) &&
           VerifyField<int8_t>(verifier, 18 /* mode */) &&
           VerifyField<float>(verifier, 20 /* min_audible_radius */) &&
           VerifyField<float>(verifier, 22 /* max_audible_radius */) &&
           VerifyField<float>(verifier, 24 /* roll_in_radius */) &&
           VerifyField<float>(verifier, 26 /* roll_out_radius */) &&
           VerifyField<float>(verifier, 28 /* roll_in_curve_factor */) &&
           VerifyField<float>(verifier, 30 /* roll_out_curve_factor */) &&
           verifier.EndTable();
  }
};

struct SoundCollectionDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_priority(float priority) { fbb_.AddElement<float>(6, priority, 1.0); }
  void add_gain(float gain) { fbb_.AddElement<float>(8, gain, 1.0); }
  void add_bus(flatbuffers::Offset<flatbuffers::String> bus) { fbb_.AddOffset(10, bus); }
  void add_loop(uint8_t loop) { fbb_.AddElement<uint8_t>(12, loop, 0); }
  void add_audio_sample_set(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AudioSampleSetEntry>>> audio_sample_set) { fbb_.AddOffset(14, audio_sample_set); }
  void add_stream(uint8_t stream) { fbb_.AddElement<uint8_t>(16, stream, 0); }
  void add_mode(Mode mode) { fbb_.AddElement<int8_t>(18, static_cast<int8_t>(mode), 0); }
  void add_min_audible_radius(float min_audible_radius) { fbb_.AddElement<float>(20, min_audible_radius, 0.0); }
  void add_max_audible_radius(float max_audible_radius) { fbb_.AddElement<float>(22, max_audible_radius, 0.0); }
  void add_roll_in_radius(float roll_in_radius) { fbb_.AddElement<float>(24, roll_in_radius, 0.0); }
  void add_roll_out_radius(float roll_out_radius) { fbb_.AddElement<float>(26, roll_out_radius, 0.0); }
  void add_roll_in_curve_factor(float roll_in_curve_factor) { fbb_.AddElement<float>(28, roll_in_curve_factor, 2.0); }
  void add_roll_out_curve_factor(float roll_out_curve_factor) { fbb_.AddElement<float>(30, roll_out_curve_factor, 0.5); }
  SoundCollectionDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SoundCollectionDefBuilder &operator=(const SoundCollectionDefBuilder &);
  flatbuffers::Offset<SoundCollectionDef> Finish() {
    auto o = flatbuffers::Offset<SoundCollectionDef>(fbb_.EndTable(start_, 14));
    return o;
  }
};

inline flatbuffers::Offset<SoundCollectionDef> CreateSoundCollectionDef(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   float priority = 1.0,
   float gain = 1.0,
   flatbuffers::Offset<flatbuffers::String> bus = 0,
   uint8_t loop = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AudioSampleSetEntry>>> audio_sample_set = 0,
   uint8_t stream = 0,
   Mode mode = Mode_Nonpositional,
   float min_audible_radius = 0.0,
   float max_audible_radius = 0.0,
   float roll_in_radius = 0.0,
   float roll_out_radius = 0.0,
   float roll_in_curve_factor = 2.0,
   float roll_out_curve_factor = 0.5) {
  SoundCollectionDefBuilder builder_(_fbb);
  builder_.add_roll_out_curve_factor(roll_out_curve_factor);
  builder_.add_roll_in_curve_factor(roll_in_curve_factor);
  builder_.add_roll_out_radius(roll_out_radius);
  builder_.add_roll_in_radius(roll_in_radius);
  builder_.add_max_audible_radius(max_audible_radius);
  builder_.add_min_audible_radius(min_audible_radius);
  builder_.add_audio_sample_set(audio_sample_set);
  builder_.add_bus(bus);
  builder_.add_gain(gain);
  builder_.add_priority(priority);
  builder_.add_name(name);
  builder_.add_mode(mode);
  builder_.add_stream(stream);
  builder_.add_loop(loop);
  return builder_.Finish();
}

inline const SoundCollectionDef *GetSoundCollectionDef(const void *buf) { return flatbuffers::GetRoot<SoundCollectionDef>(buf); }

inline bool VerifySoundCollectionDefBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<SoundCollectionDef>(); }

inline void FinishSoundCollectionDefBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<SoundCollectionDef> root) { fbb.Finish(root); }

}  // namespace pindrop

#endif  // FLATBUFFERS_GENERATED_SOUNDCOLLECTIONDEF_PINDROP_H_
