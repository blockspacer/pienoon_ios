// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MULTIPLAYER_FPL_PIE_NOON_MULTIPLAYER_H_
#define FLATBUFFERS_GENERATED_MULTIPLAYER_FPL_PIE_NOON_MULTIPLAYER_H_

#include "flatbuffers/flatbuffers.h"


namespace fpl {
namespace pie_noon {
namespace multiplayer {

struct PlayerAssignment;
struct PlayerCommand;
struct PlayerStatus;
struct StartTurn;
struct EndGame;
struct MessageRoot;

enum Data {
  Data_NONE = 0,
  Data_PlayerAssignment = 1,
  Data_PlayerCommand = 2,
  Data_StartTurn = 3,
  Data_EndGame = 4,
  Data_PlayerStatus = 5
};

inline const char **EnumNamesData() {
  static const char *names[] = { "NONE", "PlayerAssignment", "PlayerCommand", "StartTurn", "EndGame", "PlayerStatus", nullptr };
  return names;
}

inline const char *EnumNameData(Data e) { return EnumNamesData()[e]; }

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *union_obj, Data type);

struct PlayerAssignment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int8_t player_id() const { return GetField<int8_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* player_id */) &&
           verifier.EndTable();
  }
};

struct PlayerAssignmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_id(int8_t player_id) { fbb_.AddElement<int8_t>(4, player_id, 0); }
  PlayerAssignmentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PlayerAssignmentBuilder &operator=(const PlayerAssignmentBuilder &);
  flatbuffers::Offset<PlayerAssignment> Finish() {
    auto o = flatbuffers::Offset<PlayerAssignment>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<PlayerAssignment> CreatePlayerAssignment(flatbuffers::FlatBufferBuilder &_fbb,
   int8_t player_id = 0) {
  PlayerAssignmentBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct PlayerCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int8_t aim_at() const { return GetField<int8_t>(4, 0); }
  uint8_t is_firing() const { return GetField<uint8_t>(6, 0); }
  uint8_t is_blocking() const { return GetField<uint8_t>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* aim_at */) &&
           VerifyField<uint8_t>(verifier, 6 /* is_firing */) &&
           VerifyField<uint8_t>(verifier, 8 /* is_blocking */) &&
           verifier.EndTable();
  }
};

struct PlayerCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aim_at(int8_t aim_at) { fbb_.AddElement<int8_t>(4, aim_at, 0); }
  void add_is_firing(uint8_t is_firing) { fbb_.AddElement<uint8_t>(6, is_firing, 0); }
  void add_is_blocking(uint8_t is_blocking) { fbb_.AddElement<uint8_t>(8, is_blocking, 0); }
  PlayerCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PlayerCommandBuilder &operator=(const PlayerCommandBuilder &);
  flatbuffers::Offset<PlayerCommand> Finish() {
    auto o = flatbuffers::Offset<PlayerCommand>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<PlayerCommand> CreatePlayerCommand(flatbuffers::FlatBufferBuilder &_fbb,
   int8_t aim_at = 0,
   uint8_t is_firing = 0,
   uint8_t is_blocking = 0) {
  PlayerCommandBuilder builder_(_fbb);
  builder_.add_is_blocking(is_blocking);
  builder_.add_is_firing(is_firing);
  builder_.add_aim_at(aim_at);
  return builder_.Finish();
}

struct PlayerStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<uint8_t> *player_health() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(4); }
  const flatbuffers::Vector<uint8_t> *player_splats() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* player_health */) &&
           verifier.Verify(player_health()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* player_splats */) &&
           verifier.Verify(player_splats()) &&
           verifier.EndTable();
  }
};

struct PlayerStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_health(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> player_health) { fbb_.AddOffset(4, player_health); }
  void add_player_splats(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> player_splats) { fbb_.AddOffset(6, player_splats); }
  PlayerStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PlayerStatusBuilder &operator=(const PlayerStatusBuilder &);
  flatbuffers::Offset<PlayerStatus> Finish() {
    auto o = flatbuffers::Offset<PlayerStatus>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PlayerStatus> CreatePlayerStatus(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> player_health = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> player_splats = 0) {
  PlayerStatusBuilder builder_(_fbb);
  builder_.add_player_splats(player_splats);
  builder_.add_player_health(player_health);
  return builder_.Finish();
}

struct StartTurn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint16_t seconds() const { return GetField<uint16_t>(4, 0); }
  const PlayerStatus *player_status() const { return GetPointer<const PlayerStatus *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* seconds */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* player_status */) &&
           verifier.VerifyTable(player_status()) &&
           verifier.EndTable();
  }
};

struct StartTurnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seconds(uint16_t seconds) { fbb_.AddElement<uint16_t>(4, seconds, 0); }
  void add_player_status(flatbuffers::Offset<PlayerStatus> player_status) { fbb_.AddOffset(6, player_status); }
  StartTurnBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StartTurnBuilder &operator=(const StartTurnBuilder &);
  flatbuffers::Offset<StartTurn> Finish() {
    auto o = flatbuffers::Offset<StartTurn>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<StartTurn> CreateStartTurn(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t seconds = 0,
   flatbuffers::Offset<PlayerStatus> player_status = 0) {
  StartTurnBuilder builder_(_fbb);
  builder_.add_player_status(player_status);
  builder_.add_seconds(seconds);
  return builder_.Finish();
}

struct EndGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const PlayerStatus *player_status() const { return GetPointer<const PlayerStatus *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* player_status */) &&
           verifier.VerifyTable(player_status()) &&
           verifier.EndTable();
  }
};

struct EndGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_status(flatbuffers::Offset<PlayerStatus> player_status) { fbb_.AddOffset(4, player_status); }
  EndGameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EndGameBuilder &operator=(const EndGameBuilder &);
  flatbuffers::Offset<EndGame> Finish() {
    auto o = flatbuffers::Offset<EndGame>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<EndGame> CreateEndGame(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<PlayerStatus> player_status = 0) {
  EndGameBuilder builder_(_fbb);
  builder_.add_player_status(player_status);
  return builder_.Finish();
}

struct MessageRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  Data data_type() const { return static_cast<Data>(GetField<uint8_t>(4, 0)); }
  const void *data() const { return GetPointer<const void *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* data_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* data */) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct MessageRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(Data data_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(6, data); }
  MessageRootBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MessageRootBuilder &operator=(const MessageRootBuilder &);
  flatbuffers::Offset<MessageRoot> Finish() {
    auto o = flatbuffers::Offset<MessageRoot>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb,
   Data data_type = Data_NONE,
   flatbuffers::Offset<void> data = 0) {
  MessageRootBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *union_obj, Data type) {
  switch (type) {
    case Data_NONE: return true;
    case Data_PlayerAssignment: return verifier.VerifyTable(reinterpret_cast<const PlayerAssignment *>(union_obj));
    case Data_PlayerCommand: return verifier.VerifyTable(reinterpret_cast<const PlayerCommand *>(union_obj));
    case Data_StartTurn: return verifier.VerifyTable(reinterpret_cast<const StartTurn *>(union_obj));
    case Data_EndGame: return verifier.VerifyTable(reinterpret_cast<const EndGame *>(union_obj));
    case Data_PlayerStatus: return verifier.VerifyTable(reinterpret_cast<const PlayerStatus *>(union_obj));
    default: return false;
  }
}

inline const fpl::pie_noon::multiplayer::MessageRoot *GetMessageRoot(const void *buf) { return flatbuffers::GetRoot<fpl::pie_noon::multiplayer::MessageRoot>(buf); }

inline bool VerifyMessageRootBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<fpl::pie_noon::multiplayer::MessageRoot>(); }

inline void FinishMessageRootBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<fpl::pie_noon::multiplayer::MessageRoot> root) { fbb.Finish(root); }

}  // namespace multiplayer
}  // namespace pie_noon
}  // namespace fpl

#endif  // FLATBUFFERS_GENERATED_MULTIPLAYER_FPL_PIE_NOON_MULTIPLAYER_H_
