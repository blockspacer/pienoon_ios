// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CHARACTERSTATEMACHINEDEF_FPL_PIE_NOON_H_
#define FLATBUFFERS_GENERATED_CHARACTERSTATEMACHINEDEF_FPL_PIE_NOON_H_

#include "flatbuffers/flatbuffers.h"

#include "pie_noon_common_generated.h"
#include "timeline_generated.h"

namespace fpl {
namespace pie_noon {
struct Vec2i;
struct Vec2;
struct Vec3;
struct Vec4;
struct Vec4ub;
}  // namespace pie_noon
}  // namespace fpl
namespace fpl {
struct TimelineRenderable;
struct PixelOffset;
struct TimelineAccessory;
struct TimelineSound;
struct TimelineEvent;
struct Timeline;
}  // namespace fpl

namespace fpl {
namespace pie_noon {

struct Condition;
struct ConditionalEvent;
struct Transition;
struct CharacterState;
struct CharacterStateMachineDef;

enum StateId {
  StateId_Idling = 0,
  StateId_Jumping = 1,
  StateId_Joining = 2,
  StateId_Loading_1 = 3,
  StateId_Loading_2 = 4,
  StateId_Loading_3 = 5,
  StateId_Throwing = 6,
  StateId_Blocking = 7,
  StateId_HitByPie = 8,
  StateId_KO = 9,
  StateId_Won = 10,
  StateId_Count = 11
};

inline const char **EnumNamesStateId() {
  static const char *names[] = { "Idling", "Jumping", "Joining", "Loading_1", "Loading_2", "Loading_3", "Throwing", "Blocking", "HitByPie", "KO", "Won", "Count", nullptr };
  return names;
}

inline const char *EnumNameStateId(StateId e) { return EnumNamesStateId()[e]; }

enum LogicalInputs {
  LogicalInputs_ThrowPie = 1,
  LogicalInputs_Deflect = 2,
  LogicalInputs_Up = 4,
  LogicalInputs_Down = 8,
  LogicalInputs_Left = 16,
  LogicalInputs_Right = 32,
  LogicalInputs_Select = 64,
  LogicalInputs_Cancel = 128,
  LogicalInputs_JustHit = 256,
  LogicalInputs_NoHealth = 512,
  LogicalInputs_AnimationEnd = 1024,
  LogicalInputs_Won = 2048,
  LogicalInputs_Lost = 4096,
  LogicalInputs_JoinedGame = 8192,
  LogicalInputs_TriggerPieGrowth = 16384
};

enum GameModeCondition {
  GameModeCondition_AnyMode = 0,
  GameModeCondition_SinglePlayerOnly = 1,
  GameModeCondition_MultiPlayerOnly = 2
};

inline const char **EnumNamesGameModeCondition() {
  static const char *names[] = { "AnyMode", "SinglePlayerOnly", "MultiPlayerOnly", nullptr };
  return names;
}

inline const char *EnumNameGameModeCondition(GameModeCondition e) { return EnumNamesGameModeCondition()[e]; }

struct Condition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  LogicalInputs is_down() const { return static_cast<LogicalInputs>(GetField<uint16_t>(4, 0)); }
  LogicalInputs is_up() const { return static_cast<LogicalInputs>(GetField<uint16_t>(6, 0)); }
  LogicalInputs went_down() const { return static_cast<LogicalInputs>(GetField<uint16_t>(8, 0)); }
  LogicalInputs went_up() const { return static_cast<LogicalInputs>(GetField<uint16_t>(10, 0)); }
  int32_t time() const { return GetField<int32_t>(12, 0); }
  int32_t end_time() const { return GetField<int32_t>(14, 2147483647); }
  GameModeCondition game_mode() const { return static_cast<GameModeCondition>(GetField<uint16_t>(16, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, 4 /* is_down */) &&
           VerifyField<uint16_t>(verifier, 6 /* is_up */) &&
           VerifyField<uint16_t>(verifier, 8 /* went_down */) &&
           VerifyField<uint16_t>(verifier, 10 /* went_up */) &&
           VerifyField<int32_t>(verifier, 12 /* time */) &&
           VerifyField<int32_t>(verifier, 14 /* end_time */) &&
           VerifyField<uint16_t>(verifier, 16 /* game_mode */) &&
           verifier.EndTable();
  }
};

struct ConditionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_down(LogicalInputs is_down) { fbb_.AddElement<uint16_t>(4, static_cast<uint16_t>(is_down), 0); }
  void add_is_up(LogicalInputs is_up) { fbb_.AddElement<uint16_t>(6, static_cast<uint16_t>(is_up), 0); }
  void add_went_down(LogicalInputs went_down) { fbb_.AddElement<uint16_t>(8, static_cast<uint16_t>(went_down), 0); }
  void add_went_up(LogicalInputs went_up) { fbb_.AddElement<uint16_t>(10, static_cast<uint16_t>(went_up), 0); }
  void add_time(int32_t time) { fbb_.AddElement<int32_t>(12, time, 0); }
  void add_end_time(int32_t end_time) { fbb_.AddElement<int32_t>(14, end_time, 2147483647); }
  void add_game_mode(GameModeCondition game_mode) { fbb_.AddElement<uint16_t>(16, static_cast<uint16_t>(game_mode), 0); }
  ConditionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ConditionBuilder &operator=(const ConditionBuilder &);
  flatbuffers::Offset<Condition> Finish() {
    auto o = flatbuffers::Offset<Condition>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Condition> CreateCondition(flatbuffers::FlatBufferBuilder &_fbb,
   LogicalInputs is_down = static_cast<LogicalInputs>(0),
   LogicalInputs is_up = static_cast<LogicalInputs>(0),
   LogicalInputs went_down = static_cast<LogicalInputs>(0),
   LogicalInputs went_up = static_cast<LogicalInputs>(0),
   int32_t time = 0,
   int32_t end_time = 2147483647,
   GameModeCondition game_mode = GameModeCondition_AnyMode) {
  ConditionBuilder builder_(_fbb);
  builder_.add_end_time(end_time);
  builder_.add_time(time);
  builder_.add_game_mode(game_mode);
  builder_.add_went_up(went_up);
  builder_.add_went_down(went_down);
  builder_.add_is_up(is_up);
  builder_.add_is_down(is_down);
  return builder_.Finish();
}

struct ConditionalEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Condition *condition() const { return GetPointer<const Condition *>(4); }
  uint16_t event() const { return GetField<uint16_t>(6, 0); }
  uint16_t modifier() const { return GetField<uint16_t>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* condition */) &&
           verifier.VerifyTable(condition()) &&
           VerifyField<uint16_t>(verifier, 6 /* event */) &&
           VerifyField<uint16_t>(verifier, 8 /* modifier */) &&
           verifier.EndTable();
  }
};

struct ConditionalEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condition(flatbuffers::Offset<Condition> condition) { fbb_.AddOffset(4, condition); }
  void add_event(uint16_t event) { fbb_.AddElement<uint16_t>(6, event, 0); }
  void add_modifier(uint16_t modifier) { fbb_.AddElement<uint16_t>(8, modifier, 0); }
  ConditionalEventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ConditionalEventBuilder &operator=(const ConditionalEventBuilder &);
  flatbuffers::Offset<ConditionalEvent> Finish() {
    auto o = flatbuffers::Offset<ConditionalEvent>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<ConditionalEvent> CreateConditionalEvent(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<Condition> condition = 0,
   uint16_t event = 0,
   uint16_t modifier = 0) {
  ConditionalEventBuilder builder_(_fbb);
  builder_.add_condition(condition);
  builder_.add_modifier(modifier);
  builder_.add_event(event);
  return builder_.Finish();
}

struct Transition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  StateId target_state() const { return static_cast<StateId>(GetField<int8_t>(4, 0)); }
  const Condition *condition() const { return GetPointer<const Condition *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* target_state */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* condition */) &&
           verifier.VerifyTable(condition()) &&
           verifier.EndTable();
  }
};

struct TransitionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target_state(StateId target_state) { fbb_.AddElement<int8_t>(4, static_cast<int8_t>(target_state), 0); }
  void add_condition(flatbuffers::Offset<Condition> condition) { fbb_.AddOffset(6, condition); }
  TransitionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransitionBuilder &operator=(const TransitionBuilder &);
  flatbuffers::Offset<Transition> Finish() {
    auto o = flatbuffers::Offset<Transition>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Transition> CreateTransition(flatbuffers::FlatBufferBuilder &_fbb,
   StateId target_state = StateId_Idling,
   flatbuffers::Offset<Condition> condition = 0) {
  TransitionBuilder builder_(_fbb);
  builder_.add_condition(condition);
  builder_.add_target_state(target_state);
  return builder_.Finish();
}

struct CharacterState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  StateId id() const { return static_cast<StateId>(GetField<int8_t>(4, 0)); }
  const flatbuffers::Vector<flatbuffers::Offset<Transition>> *transitions() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transition>> *>(6); }
  const fpl::Timeline *timeline() const { return GetPointer<const fpl::Timeline *>(8); }
  const flatbuffers::Vector<flatbuffers::Offset<ConditionalEvent>> *conditional_events() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ConditionalEvent>> *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* transitions */) &&
           verifier.Verify(transitions()) &&
           verifier.VerifyVectorOfTables(transitions()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* timeline */) &&
           verifier.VerifyTable(timeline()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* conditional_events */) &&
           verifier.Verify(conditional_events()) &&
           verifier.VerifyVectorOfTables(conditional_events()) &&
           verifier.EndTable();
  }
};

struct CharacterStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(StateId id) { fbb_.AddElement<int8_t>(4, static_cast<int8_t>(id), 0); }
  void add_transitions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transition>>> transitions) { fbb_.AddOffset(6, transitions); }
  void add_timeline(flatbuffers::Offset<fpl::Timeline> timeline) { fbb_.AddOffset(8, timeline); }
  void add_conditional_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConditionalEvent>>> conditional_events) { fbb_.AddOffset(10, conditional_events); }
  CharacterStateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CharacterStateBuilder &operator=(const CharacterStateBuilder &);
  flatbuffers::Offset<CharacterState> Finish() {
    auto o = flatbuffers::Offset<CharacterState>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<CharacterState> CreateCharacterState(flatbuffers::FlatBufferBuilder &_fbb,
   StateId id = StateId_Idling,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transition>>> transitions = 0,
   flatbuffers::Offset<fpl::Timeline> timeline = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConditionalEvent>>> conditional_events = 0) {
  CharacterStateBuilder builder_(_fbb);
  builder_.add_conditional_events(conditional_events);
  builder_.add_timeline(timeline);
  builder_.add_transitions(transitions);
  builder_.add_id(id);
  return builder_.Finish();
}

struct CharacterStateMachineDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<CharacterState>> *states() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CharacterState>> *>(4); }
  StateId initial_state() const { return static_cast<StateId>(GetField<int8_t>(6, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* states */) &&
           verifier.Verify(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           VerifyField<int8_t>(verifier, 6 /* initial_state */) &&
           verifier.EndTable();
  }
};

struct CharacterStateMachineDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CharacterState>>> states) { fbb_.AddOffset(4, states); }
  void add_initial_state(StateId initial_state) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(initial_state), 0); }
  CharacterStateMachineDefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CharacterStateMachineDefBuilder &operator=(const CharacterStateMachineDefBuilder &);
  flatbuffers::Offset<CharacterStateMachineDef> Finish() {
    auto o = flatbuffers::Offset<CharacterStateMachineDef>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<CharacterStateMachineDef> CreateCharacterStateMachineDef(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CharacterState>>> states = 0,
   StateId initial_state = StateId_Idling) {
  CharacterStateMachineDefBuilder builder_(_fbb);
  builder_.add_states(states);
  builder_.add_initial_state(initial_state);
  return builder_.Finish();
}

inline const fpl::pie_noon::CharacterStateMachineDef *GetCharacterStateMachineDef(const void *buf) { return flatbuffers::GetRoot<fpl::pie_noon::CharacterStateMachineDef>(buf); }

inline bool VerifyCharacterStateMachineDefBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<fpl::pie_noon::CharacterStateMachineDef>(); }

inline void FinishCharacterStateMachineDefBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<fpl::pie_noon::CharacterStateMachineDef> root) { fbb.Finish(root); }

}  // namespace pie_noon
}  // namespace fpl

#endif  // FLATBUFFERS_GENERATED_CHARACTERSTATEMACHINEDEF_FPL_PIE_NOON_H_
